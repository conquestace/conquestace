---
/* components/WildcardLoader.astro */
---


<!-- â”€â”€â”€â”€â”€ top controls â”€â”€â”€â”€â”€ -->
<div class="flex flex-wrap items-center gap-3">
  <label class="text-lightblue text-sm">
    Collection:
    <select id="collectionSelector" class="bg-slatecard p-1 rounded">
      <option value="danbooru">Danbooru</option>
      <option value="natural-language">Natural-language</option>
    </select>
  </label>
</div>

<!-- â”€â”€â”€â”€â”€ directory tree â”€â”€â”€â”€â”€ -->
<label class="text-lightblue text-sm block mt-2">Wildcards:</label>
<div id="treeContainer" class="tree"></div>

<!-- â”€â”€â”€â”€â”€ drag-drop box & file list â”€â”€â”€â”€â”€ -->
<div class="space-y-3 mt-4">
  <div id="drop" class="drop-zone">
    <p>ğŸ“ Drag wildcard .txt files here<br/>or click to browse</p>
    <input id="fileInput" type="file" accept=".txt" multiple hidden />
  </div>
  <ul id="fileList" class="space-y-1 text-lightblue text-sm font-mono"></ul>
</div>
 <button id="loadDefaults"
          class="bg-lightblue text-midnight px-3 py-1 rounded">
    ğŸ“‚ Load wildcards
  </button>

  <button id="clearWildcards"
          class="bg-red-500 text-white px-3 py-1 rounded">
    ğŸ§¹ Clear wildcards
  </button>
<script is:client>
  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ constants â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const HF_BASE =
    'https://huggingface.co/datasets/ConquestAce/wildcards/resolve/main/';
  const MANIFEST_MAP = {
    'danbooru':         'danbooru/manifest.json',
    'natural-language': 'natural-language/manifest.json'
  };

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ element refs â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const drop      = document.getElementById('drop');
  const input     = document.getElementById('fileInput');
  const listEl    = document.getElementById('fileList');
  const collSel   = document.getElementById('collectionSelector');
  const treeEl    = document.getElementById('treeContainer');
  const loadBtn   = document.getElementById('loadDefaults');
  const clearBtn  = document.getElementById('clearWildcards');

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ state â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const store         = new Map();          // path â†’ lines[]
  const selectedPaths = new Set();          // checked file paths
  const manifestCache = {};                 // collection id â†’ manifest[]

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ utility â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const dispatch = () =>
    window.dispatchEvent(new CustomEvent('wildcards-loaded',
      { detail: Object.fromEntries(store) }));

  const updateList = () => {
    listEl.textContent = '';
    [...store.keys()].sort().forEach(name => {
      const li = document.createElement('li');
      li.className =
        'flex items-center justify-between bg-slatecard rounded px-2 py-1';
      const span = document.createElement('span');
      span.className = 'truncate';
      span.textContent = name;
      const btn = document.createElement('button');
      btn.className = 'text-red-400';
      btn.textContent = 'ğŸ—‘ï¸';
      btn.onclick = () => { store.delete(name); updateList(); dispatch(); };
      li.append(span, btn);
      listEl.appendChild(li);
    });
  };

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ drag-drop & picker â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  drop.onclick = () => input.click();
  input.onchange = () => addFiles(input.files);
  ['dragenter','dragover'].forEach(ev =>
    drop.addEventListener(ev, e => { e.preventDefault(); drop.classList.add('drag'); }));
  ['dragleave','drop'].forEach(ev =>
    drop.addEventListener(ev, e => { e.preventDefault(); drop.classList.remove('drag'); }));
  drop.addEventListener('drop', e => addFiles(e.dataTransfer.files));

  async function addFiles(fileList) {
    for (const f of fileList) {
      if (f.type !== 'text/plain') continue;
      store.set(f.name, (await f.text()).trim().split(/\r?\n/));
    }
    updateList(); dispatch();
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ manifest loader â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  async function getManifest(collection) {
    if (manifestCache[collection]) return manifestCache[collection];
    const data = await fetch(HF_BASE + MANIFEST_MAP[collection]).then(r=>r.json());
    manifestCache[collection] = data;
    return data;
  }

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ build tree â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  function insert(node, parts, entry) {
    if (parts.length === 1) {
      node.files ??= [];
      node.files.push({ label: parts[0], path: entry.path });
      return;
    }
    const head = parts[0];
    node.dirs ??= {};
    node.dirs[head] ??= {};
    insert(node.dirs[head], parts.slice(1), entry);
  }

  function render(node, parent) {
    if (node.dirs) {
      Object.keys(node.dirs).sort().forEach(name => {
        const details = document.createElement('details');
        const summary = document.createElement('summary');
        summary.textContent = name;
        details.appendChild(summary);
        const ul = document.createElement('ul');
        render(node.dirs[name], ul);
        details.appendChild(ul);
        parent.appendChild(details);
      });
    }
    if (node.files) {
      node.files.sort((a,b)=>a.label.localeCompare(b.label)).forEach(f => {
        const li = document.createElement('li');
        const label = document.createElement('label');
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.onchange = () => {
          if (cb.checked) selectedPaths.add(f.path);
          else selectedPaths.delete(f.path);
        };
        label.append(cb, document.createTextNode(' ' + f.label));
        li.appendChild(label);
        parent.appendChild(li);
      });
    }
  }

  async function populateTree() {
    treeEl.textContent='';
    selectedPaths.clear();
    const manifest = await getManifest(collSel.value);
    const root = {};
    manifest.forEach(e => {
      const parts = e.path.split('/').slice(1); // skip collection id
      insert(root, parts, e);
    });
    const ul = document.createElement('ul');
    render(root, ul);
    treeEl.appendChild(ul);
  }

  collSel.addEventListener('change', populateTree);
  populateTree();             // initial load

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ load defaults â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  loadBtn.onclick = async () => {
    const coll   = collSel.value;
    const manifest = await getManifest(coll);

    const wantAll = selectedPaths.size === 0;

    for (const { path } of manifest) {
      if (!wantAll && !selectedPaths.has(path)) continue;
      if (store.has(path)) continue;

      const txt = await fetch(HF_BASE + path).then(r=>r.text());
      store.set(path, txt.trim().split(/\r?\n/));
    }
    updateList(); dispatch();
  };

  /* â”€â”€â”€â”€â”€â”€â”€â”€â”€ clear all â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  clearBtn.onclick = () => { store.clear(); updateList(); dispatch(); };
</script>
